name: Website SSL and Domain Check

on:
  schedule:
    - cron: "0 7 * * *" # daily at 09:00 EET (07:00 UTC)
  workflow_dispatch:

jobs:
  ssl-domain-check:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install whois
        run: sudo apt-get update && sudo apt-get install -y whois

      - name: Check website SSL Certificate and Domain
        run: |
          set -uo pipefail

          DOMAIN="esl-ui.com"
          SSL_WARNING_DAYS=30
          DOMAIN_WARNING_DAYS=60
          NETWORK_TIMEOUT=15  # seconds for network operations

          # Create labels if they don't exist
          gh label create monitoring --description "Monitoring alerts" --color "0075ca" --force 2>/dev/null || true
          gh label create "Monitor: SSL Certificate" --description "SSL certificate monitoring" --color "d73a4a" --force 2>/dev/null || true
          gh label create "Monitor: Domain" --description "Domain expiry monitoring" --color "d73a4a" --force 2>/dev/null || true

          create_or_update_issue() {
            local label="$1"
            local title="$2"
            local body="$3"
            local search_term="$4"

            existing_issue=$(gh issue list --label "$label" --state "open" --search "in:title $search_term" --json number --jq '.[0].number' || echo "")

            if [ -z "$existing_issue" ]; then
              echo "Creating new issue with label: $label"
              gh issue create --title "$title" --body "$body" --label "$label" --label monitoring
            else
              echo "Issue already exists (#$existing_issue), updating..."
              gh issue edit "$existing_issue" --body "$body"
            fi
          }

          close_issue_if_exists() {
            local label="$1"
            local search_term="$2"
            local comment="$3"

            existing_issue=$(gh issue list --label "$label" --state "open" --search "in:title $search_term" --json number --jq '.[0].number' || echo "")
            if [ -n "$existing_issue" ]; then
              echo "Closing resolved $label issue #$existing_issue"
              gh issue close "$existing_issue" --comment "$comment" --reason completed
            fi
          }

          # Track overall status
          overall_status=0

          echo "Checking SSL certificate for $DOMAIN..."

          # Check SSL certificate
          ssl_info=$(echo | timeout "${NETWORK_TIMEOUT}s" openssl s_client -servername $DOMAIN -connect $DOMAIN:443 2>/dev/null | openssl x509 -noout -dates)
          echo "SSL Certificate info:"
          echo "$ssl_info"

          # Get expiry date
          expiry_date=$(echo "$ssl_info" | grep "notAfter" | cut -d= -f2)
          expiry_timestamp=$(date -d "$expiry_date" +%s 2>/dev/null)
          current_timestamp=$(date +%s)

          # Check if expiry_timestamp is a valid integer
          if ! [[ "$expiry_timestamp" =~ ^[0-9]+$ ]]; then
            echo "❌ Error: Could not parse SSL certificate expiry date for $DOMAIN."
            echo "Raw openssl output:"
            echo "$ssl_info"
            echo "Parsed expiry_date: '$expiry_date'"
            if [ "$overall_status" -lt 2 ]; then overall_status=2; fi
            body=$(printf "Could not parse SSL certificate expiry date for $DOMAIN.\n\nRaw openssl output:\n\`\`\`\n%s\n\`\`\`\nParsed expiry_date: '%s'\n\n*Updated: %s*" "$ssl_info" "$expiry_date" "$(date)")
            create_or_update_issue "Monitor: SSL Certificate" \
              "❌ SSL Certificate Parse Failure: $DOMAIN" \
              "$body" \
              "SSL Certificate Parse Failure"
          else
            days_until_expiry=$(( (expiry_timestamp - current_timestamp) / 86400 ))

            echo "Days until SSL expiry: $days_until_expiry"

            if [ "$days_until_expiry" -lt "$SSL_WARNING_DAYS" ]; then
              echo "⚠️ SSL certificate expires in $days_until_expiry days!"

              body=$(printf "SSL certificate for $DOMAIN expires in **%s days** (on %s).\n\nPlease renew the certificate before expiration.\n\n*Updated: %s*" "$days_until_expiry" "$expiry_date" "$(date)")
              create_or_update_issue "Monitor: SSL Certificate" \
                "⚠️ SSL Certificate Expiring Soon: $DOMAIN" \
                "$body" \
                "SSL Certificate Expiring Soon"

              if [ "$overall_status" -lt 1 ]; then overall_status=1; fi
            else
              echo "✅ SSL certificate is valid for $days_until_expiry more days"

              close_issue_if_exists "Monitor: SSL Certificate" \
                "SSL Certificate Expiring Soon" \
                "✅ SSL certificate is now valid for $days_until_expiry more days. Issue resolved."
            fi
          fi

          echo ""
          echo "Checking domain expiry for $DOMAIN..."

          # Run whois once and reuse output
          full_whois=$(timeout "${NETWORK_TIMEOUT}s" whois $DOMAIN)
          domain_info=$(echo "$full_whois" | grep -i "expir")
          echo "Domain expiry info:"
          echo "$domain_info"

          # Try to get domain expiry date
          expiry_line=$(echo "$full_whois" | grep -Ei "registry expiry date|expiration date|expiry date" | head -1)
          if [ -n "$expiry_line" ]; then
            expiry_date=$(echo "$expiry_line" | cut -d: -f2- | xargs)
            echo "Domain expires: $expiry_date"

            # Convert to timestamp (may need adaptation depending on format)
            expiry_timestamp=$(date -d "$expiry_date" +%s 2>/dev/null)

            # Check if expiry_timestamp is a valid integer
            if [[ "$expiry_timestamp" =~ ^[0-9]+$ ]]; then
              current_timestamp=$(date +%s)
              days_until_expiry=$(( (expiry_timestamp - current_timestamp) / 86400 ))

              echo "Days until domain expiry: $days_until_expiry"

              if [ "$days_until_expiry" -lt "$DOMAIN_WARNING_DAYS" ]; then
                echo "⚠️ Domain expires in $days_until_expiry days!"

                body=$(printf "Domain $DOMAIN expires in **%s days** (on %s).\n\nPlease renew the domain before expiration.\n\n*Updated: %s*" "$days_until_expiry" "$expiry_date" "$(date)")
                create_or_update_issue "Monitor: Domain" \
                  "⚠️ Domain Expiring Soon: $DOMAIN" \
                  "$body" \
                  "Domain Expiring Soon"

                if [ "$overall_status" -lt 1 ]; then overall_status=1; fi
              else
                echo "✅ Domain is valid for $days_until_expiry more days"

                close_issue_if_exists "Monitor: Domain" \
                  "Domain Expiring Soon" \
                  "✅ Domain is now valid for $days_until_expiry more days. Issue resolved."
              fi
            else
              echo "❌ Error: Could not parse domain expiry date timestamp."
              echo "Parsed expiry_date: '$expiry_date'"
              if [ "$overall_status" -lt 2 ]; then overall_status=2; fi
              body=$(printf "Could not parse the domain expiry date timestamp for **$DOMAIN**.\n\nParsed expiry_date: '%s'\n\nThis may indicate an unexpected date format.\n\nPlease investigate.\n\n*Updated: %s*" "$expiry_date" "$(date)")
              create_or_update_issue "Monitor: Domain" \
                "❌ Domain Expiry Parse Failure: $DOMAIN" \
                "$body" \
                "Domain Expiry Parse Failure"
            fi
          else
            echo "Could not determine domain expiry date"
            if [ "$overall_status" -lt 2 ]; then overall_status=2; fi
            body=$(printf "Could not determine the domain expiry date for **$DOMAIN**.\n\nThis may indicate a change in whois output format, a monitoring failure, or a domain issue.\n\nPlease investigate.\n\n*Updated: %s*" "$(date)")
            create_or_update_issue "Monitor: Domain" \
              "❌ Domain Expiry Parse Failure: $DOMAIN" \
              "$body" \
              "Domain Expiry Parse Failure"
          fi

          # Exit with aggregated status
          exit $overall_status
